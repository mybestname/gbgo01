package main

type foo interface {
	fooFunc()
}
type foo1 struct{}
func (foo1) fooFunc() {}
type foo2 struct{}
func (*foo2) fooFunc() {}

func main() {
	var f foo
	f= foo1{}
	f.fooFunc()   // When the method is called, an escape occurs because the method is dynamically allocated

	var f2 foo
	f2 = &foo2{}
	f2.fooFunc()
}

//go:generate go build -gcflags "-m=2" main2.go
// go1.16.4 输出：
//./main2.go:7:6: can inline foo1.fooFunc with cost 0 as: method(foo1) func() {  }
//./main2.go:9:6: can inline (*foo2).fooFunc with cost 0 as: method(*foo2) func() {  }
//./main2.go:11:6: cannot inline main: function too complex: cost 137 exceeds budget 80
//./main2.go:17:7: &foo2{} escapes to heap:
//./main2.go:17:7:   flow: f2 = &{storage for &foo2{}}:
//./main2.go:17:7:     from &foo2{} (spill) at ./main2.go:17:7
//./main2.go:17:7:     from &foo2{} (interface-converted) at ./main2.go:17:5
//./main2.go:17:7:     from f2 = &foo2{} (assign) at ./main2.go:17:5
//./main2.go:17:7:   flow: {heap} = f2:
//./main2.go:17:7:     from f2.fooFunc() (call parameter) at ./main2.go:18:12
//./main2.go:13:3: foo1{} escapes to heap:
//./main2.go:13:3:   flow: f = &{storage for foo1{}}:
//./main2.go:13:3:     from foo1{} (spill) at ./main2.go:13:3
//./main2.go:13:3:     from f = foo1{} (assign) at ./main2.go:13:3
//./main2.go:13:3:   flow: {heap} = f:
//./main2.go:13:3:     from f.fooFunc() (call parameter) at ./main2.go:14:11
//./main2.go:13:3: foo1{} escapes to heap
//./main2.go:17:7: &foo2{} escapes to heap
//<autogenerated>:1: parameter .this leaks to {heap} with derefs=0:
//<autogenerated>:1:   flow: {heap} = .this:
//<autogenerated>:1:     from .this.fooFunc() (call parameter) at <autogenerated>:1
//<autogenerated>:1: leaking param: .this
//<autogenerated>:1: inlining call to foo1.fooFunc method(foo1) func() {  }
//<autogenerated>:1: .this does not escape

//
// 对比go1.13.15:
//
// $ /goroot-go1.a3.15/bin/go tool compile -m -m -newescape=false main2.go
//main2.go:7:6: can inline foo1.fooFunc as: method(foo1) func() {  }
//main2.go:9:6: can inline (*foo2).fooFunc as: method(*foo2) func() {  }
//main2.go:11:6: cannot inline main: function too complex: cost 137 exceeds budget 80
//main2.go:13:3: foo1 literal escapes to heap
//main2.go:13:3:  from f (assigned) at main2.go:13:3
//main2.go:13:3:  from f.fooFunc() (receiver in indirect call) at main2.go:14:11
//main2.go:17:5: &foo2 literal escapes to heap
//main2.go:17:5:  from f2 (assigned) at main2.go:17:5
//main2.go:17:5:  from f2.fooFunc() (receiver in indirect call) at main2.go:18:12
//main2.go:17:7: &foo2 literal escapes to heap
//main2.go:17:7:  from &foo2 literal (interface-converted) at main2.go:17:5
//main2.go:17:7:  from f2 (assigned) at main2.go:17:5
//main2.go:17:7:  from f2.fooFunc() (receiver in indirect call) at main2.go:18:12
//<autogenerated>:1: leaking param: .this
//<autogenerated>:1:      from .this.fooFunc() (receiver in indirect call) at <autogenerated>:1
//<autogenerated>:1: inlining call to foo1.fooFunc method(foo1) func() {  }
//<autogenerated>:1: (*foo1).fooFunc .this does not escape

// 对比go1.14.0:
// $ /goroot-go1.a4.01/bin/go tool compile -m -m  main2.go
//main2.go:7:6: can inline foo1.fooFunc as: method(foo1) func() {  }
//main2.go:9:6: can inline (*foo2).fooFunc as: method(*foo2) func() {  }
//main2.go:11:6: cannot inline main: function too complex: cost 137 exceeds budget 80
//main2.go:17:7: &foo2 literal escapes to heap:
//main2.go:17:7:   flow: f2 = &{storage for &foo2 literal}:
//main2.go:17:7:     from &foo2 literal (spill) at main2.go:17:7
//main2.go:17:7:     from &foo2 literal (interface-converted) at main2.go:17:5
//main2.go:17:7:     from f2 = &foo2 literal (assign) at main2.go:17:5
//main2.go:17:7:   flow: {heap} = f2:
//main2.go:17:7:     from f2.fooFunc() (call parameter) at main2.go:18:12
//main2.go:13:3: foo1 literal escapes to heap:
//main2.go:13:3:   flow: f = &{storage for foo1 literal}:
//main2.go:13:3:     from foo1 literal (spill) at main2.go:13:3
//main2.go:13:3:     from f = foo1 literal (assign) at main2.go:13:3
//main2.go:13:3:   flow: {heap} = f:
//main2.go:13:3:     from f.fooFunc() (call parameter) at main2.go:14:11
//main2.go:13:3: foo1 literal escapes to heap
//main2.go:17:7: &foo2 literal escapes to heap
//<autogenerated>:1: parameter .this leaks to {heap} with derefs=0:
//<autogenerated>:1:   flow: {heap} = .this:
//<autogenerated>:1:     from .this.fooFunc() (call parameter) at <autogenerated>:1
//<autogenerated>:1: leaking param: .this
//<autogenerated>:1: inlining call to foo1.fooFunc method(foo1) func() {  }
//<autogenerated>:1: .this does not escape


// 可以看出，自从go1.14重写了esc.go后，其实输出情况反而不如1.13版了。（最新的go1.16.4版的结果其实和go1.14没有太大区别。）
// 首先：顺序：旧版是按顺序输出的。这样直观且清晰。
