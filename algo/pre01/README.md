# 课程例题预习 (From leetcode)

## 数组、双指针：

### 1.删除排序数组中的重复项 
- https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/ 
- 注意：数组是排序好的。有序的。
- 注意：已经提示了双指针。  
- 那么只要使用另外一个游标自增来表示清除后的长度，即可满足空间O(1)
- [解法](01/remove_dup.cpp)

## 数组、哈希表：

### 2.合并两个有序数组
- https://leetcode-cn.com/problems/merge-sorted-array/
- 注意：数组是有序的
- 注意：nums1的空间为m+n，所以要把nums2并入nums的空间
- 注意：得到的数组要继续保持有序。
- 注意：合并数组的长度是已知的，即m+n
- 那么从m+n倒序自减，把nums2或者nums2的元素，按大小顺序依次回填。
  - 既有三个游标，m+n，m和n
- [解法](02/merge_array.cpp)

### 3.两数之和
- https://leetcode-cn.com/problems/two-sum/description/
- 给定一个整数数组nums和一个整数目标值target，
  - 在该数组中找出和为目标值target的那两个整数，并返回它们的数组下标。
  - 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
  - 你可以按任意顺序返回答案。
- 注意：数组是否有序不知道
- 注意：答案不要求顺序。

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```
- 思路：已经提示使用hashmap来解决。假设已有一个哈希表，其中的k存元素，v存元素位置。
  那么只要对nums的每个元素，查找哈希表是否已经存在一个k = target-nums[i]即可。
  如果找到，即可返回。如果没有找到，就顺便把当前元素存入哈希表。

- [解法](03/two_sum.cpp)

## 树、递归：

### 4. N叉树的前序遍历
- https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/description/
- 给定一个 N叉树，返回其节点值的前序遍历。
  - N叉树在输入中
    - 按层序遍历进行序列化表示
    - 每组子节点由空值 null 分隔。
- 递归法很简单，使用迭代法完成

```c
             1
          3    2   4
       5    6

输入：root = [1,null,3,2,4,null,5,6]
输出：[1,3,5,6,2,4]
                          1
                   2    3     4    5
                      6   7   8   9  10
                          11  12  13
                          14

输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出：[1,2,3,6,7,11,14,4,8,12,5,9,13,10]
```

注意：

- 前序遍历概念 
  - 深度（前/中/后）
    - **前序**（先根/先序）：**根/左/右**。
    - 中序（左/根/右）
    - 后序（左/右/根）
  - 层次（广度）
- N叉树和二叉树的前序遍历原理完全一样。
- 二叉树非递归解法需要用到栈辅助，N叉树同样如此。
- 将父节点的所有孩子节点逆序入栈，逆序的目的是为了让前序节点永远在栈顶。
- 依次循环直到栈里所有元素都出栈。输出的结果即为 N 叉树的前序遍历。
- 时间复杂度 O(n)，空间复杂度 O(n)。

- 思路：已经提示使用栈这种数据结构来解决。
  
- [解法](04/nary_pre_trav.cpp)


### 5. 组合
- https://leetcode-cn.com/problems/combinations/
- 给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。
- 组合问题是回溯法解决的经典问题
- backtracking
- 回溯就是通过不同的尝试来生成问题的解，有点类似于穷举，但是和穷举不同的是回溯会“剪枝”
  - 剪枝的意思也就是说对已经知道错误的结果没必要再枚举接下来的答案
  - 因为是一个搜索树，剪枝就是把没有必要的树枝剪掉。
- 回溯搜索是深度优先搜索（DFS）的一种  
  - 回溯和DFS，其主要的区别是
    - 回溯法在求解过程中不保留完整的树结构，
    - 而深度优先搜索则记下完整的搜索树。
- 为了减少存储空间，在深度优先搜索中，用标志的方法记录访问过的状态，
    - 这种处理方法使得深度优先搜索法与回溯法没什么区别  
- 递归就是在函数中调用函数本身来解决问题。    
   - 而回溯可以理解为对递归的优化，在**递归函数的参数中传递一个子状态**，
     - 那么就可以**根据子状态的变化，来对递归进行某种控制**。
     - 可以理解为 走迷宫
     - 可以理解为 全排列 vs. 组合  
     - 可以理解为 嵌套循环 vs. 某些嵌套的提前结束。
```
输入: n = 4, k = 2
输出:
[
[2,4],
[3,4],
[2,3],
[1,2],
[1,3],
[1,4],
]
```

- [解法](05/combination.cpp)

## 贪心算法：

### 6.买卖股票的最佳时机 II
- https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/description/
- 问题
   - 给定一个数组 `prices` ，其中 `prices[i]` 是一支给定股票第 `i` 天的价格。
   - 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易
      - 多次买卖一支股票。
- 注意
  - 你不能同时参与多笔交易
     - 你必须在再次购买前出售掉之前的股票。
- 示例
  - 例1
  ```shell
  输入: prices = [7,1,5,3,6,4]
  输出: 7
  解释: 
     - 在第 2 天（股票价格 = 1）的时候买入，
     - 在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     - 在第 4 天（股票价格 = 3）的时候买入，
     - 在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
  ```
  - 例2
  ```shell
  输入: prices = [1,2,3,4,5]
  输出: 4
  解释: 
     - 在第 1 天（股票价格 = 1）的时候买入，
     - 在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     - 注意你不能在第 1 天和第 2 天接连购买股票。
     - 这样属于同时参与了多笔交易，必须在再次购买前出售掉之前的股票。
  ```
  - 例3
  ```shell
  输入: prices = [7,6,4,3,1]
  输出: 0
  解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
  ```
- 思路： 
  - 贪心策略：
    - 全局结果=sum(局部结果)
    - 局部结果互不相干，
    - 局部最优的策略也同样是全局最优
  - 股票的全局收益 = sum（每天的局部收益）
  - 每天的结果相互不想干
  - 全局的最优即所有局部最优的累加。
- [解法](06/stock.cpp)

## 动态规划：

### 7. 最小路径和
- https://leetcode-cn.com/problems/minimum-path-sum/
- 问题
  - 给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
  -
- 示例：
  ```
       1  3  1          1  3  1
       1  5  1    ===>        1   ==> 1 + 3 + 1 + 1 + 1 = 7
       4  2  1                1
  输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
  输出：7
  解释：因为路径 1→3→1→1→1 的总和最小。
  ```
  ```
     1 2 3         1
     4 5 6   ==>   4 5 6  ==> 1 + 4 + 5 + 6 = 12
   
  输入：grid = [[1,2,3],[4,5,6]]
  输出：12
  ```
- 注意 : 每次只能向下或者向右移动一步。 
- 思路 : 用一个二维数组来动态规划
  - 动规是由前一个状态推导出来的，而贪心是局部直接选最优的
  - 确定dp数组为dp[i][j], 为最优总量和
  - 确定dp的状态推导公式为：dp[i][j] = min(dp[i-1][j],dp[i][j-1])+grid[i][j] (每次只能向下或者向右移动, grid是输入数组)
- [解法](07/min_path_sum.cpp)


### 8. 最大正方形
- https://leetcode-cn.com/problems/maximal-square/
- 问题
  - 在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积。
- 示例
  ```
  1 0 1 0 0
  1 0 1 1 1       ==>       1 1 
  1 1 1 1 1                 1 1
  1 0 0 1 0
  输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
  输出：4
  ```
  ```
  输入：matrix = [["0","1"],["1","0"]]
  输出：1
  ```
  ```
  输入：matrix = [["0"]]
  输出：0
  ```
- 思路: 
  - 依旧使用动态规划
  - 确定dp[i][j]为最大正方形的变长
    1 1
    1 ?  min(dp[i-1][j-1], dp[i-1]dp[j], dp[i]dp[j-1]) = 1 => dp[i][j] = 2 = (1 + 1)
    
    1 1 1
    1 2 2
    状态推导公式：dp[i][j] = min(dp[i-1][j-1], dp[i-1]dp[j], dp[i]dp[j-1]) + 1 
  - 面积为边长^2
- [解法](08/maximal_square.cpp)  

## 字符串：

### 9. 翻转字符串里的单词
- https://leetcode-cn.com/problems/reverse-words-in-a-string/
- 问题：
  - 给你一个字符串 s ，逐个翻转字符串中的所有 单词 。
  - 单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。
  - 请你返回一个翻转 s 中单词顺序并用单个空格相连的字符串。
- 注意：
  - 输入字符串 s 可以在前面、后面或者单词间包含多余的空格。
  - 翻转后单词间应当仅用一个空格分隔。
  - 翻转后的字符串中不应包含额外的空格。
- 示例：
  ```
  输入：s = "the sky is blue"
  输出："blue is sky the"
  输入：s = "  hello world  "
  输出："world hello"
  解释：输入字符串可以在前面或者后面包含多余的空格，但是翻转后的字符不能包括。
  输入：s = "a good   example"
  输出："example good a"
  解释：如果两个单词间有多余的空格，将翻转后单词间的空格减少到只含一个。
  输入：s = "  Bob    Loves  Alice   "
  输出："Alice Loves Bob"
  ```
- 思路：
  - 传统方法：
    1. 首先去除冗余空格 (使用双指针)
    2. 将整个字符串翻转
    3. 根据空格分隔的子字符串逐一翻转。 2和3可以调用一个reverse的子函数。
  - 如果有slice
    1. 则可以返回包含所有单词的slice（相当于返回索引数组）
    2。翻转索引数组
    3。重新构造string。   
- 注意
  
  
- [解法](09/reverse-words.cpp) 


