## 329. 矩阵中的最长递增路径
- https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/
- https://leetcode.com/problems/longest-increasing-path-in-a-matrix/
- 给定一个 m x n 整数矩阵 matrix ，找出其中 **最长递增路径** 的长度。
- 对于每个单元格，你可以往上，下，左，右四个方向移动。 
- 你 **不能** 在 **对角线** 方向上移动或移动到 边界外（即**不允许环绕**）。

```
示例 1：
           9    9    4
           ^ 
           6    6    8
           ^ 
           2 <- 1    1

输入：matrix = [[9,9,4],[6,6,8],[2,1,1]]
输出：4
解释：最长递增路径为 [1, 2, 6, 9]。
```
```
示例 2：

           3  -> 4  -> 5
                       v 
           3     2     6
           
           2     2     1

输入：matrix = [[3,4,5],[3,2,6],[2,2,1]]
输出：4
解释：最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。
```
```
示例 3：
        
输入：matrix = [[1]]
输出：1
```

### 思路
- 只能递增  DAG
- 最长路径如果有环，那么就无穷循环了。
- 先画图，寻找思路
```
只能从小往大走
           9    9 <- 4
           ^    ^    v 
           6    6 -> 8
           ^    ^    ^ 
           2 <- 1    1

```
- DFS的思路
  - 从点1（[3,2] 第3行，第二列) 出发可以走多远？
  - 从start出发可以走多远？
     ``` 
                   how_far(3,2)
                            1
                   /           \
            how_far(3,1)     how_far(2,2)       上下左右，至多只有四条出边。
                     2                6
     ```
  - 时间复杂度太高！
    - 按2个分叉考虑，也有2^n级别的复杂组
    - 考虑如何记忆化（不要重复计算）确保每个问题只算一次。

- BFS的思路
  - 和以前的BFS不同，因为要考虑最长路径，所以不能只是考虑出边，还需要考虑入边
  - 要完成了到达某个点所有的路径的搜索后，才能BFS到下一层。
  - 还是拓扑排序，入度数--，直到减为0是，这个点才能push到队列。