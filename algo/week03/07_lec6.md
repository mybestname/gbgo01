# 第 6 课 深度优先搜索、广度优先搜索 (7.3)

## 要点
- 状态与状态空间
- DFS的实现与应用（深度优先）
- BFS的实现与应用（广度优先）
- DFS和BFS的对比

## 本课的重要性
- **第一次**归纳总结：**状态**、**状态空间**、**把问题抽象为树或图**
- **搜索是解决一切问题的万金油** ，众多NP问题（没有多项式时间问题）都需要靠搜索。
- 学会定义**搜索框架** ， 学习**动规** 和 **图论**的关键。
- 搜索题是**训练代码能力最有效**的题目类型。

## 状态与状态空间
### 状态
- 算法访问的所有信息
- 函数访问的所有变量
- 动态变化的数据。
- 状态：程序维护的所有动态数据构成的集合。

### 状态空间
- 所有可能状态构成的集合就是一个问题的状态空间。
- 把状态做为点，如果从一个状态可以到达另一个状态，就连一条边。
- 这样整个**状态空间**抽象为一个**有向图**
- 对问题的求解，就是对这张**图的遍历**。

对于简单的记票问题：
  - n个点，n-1条边的有向图。
  - 整张有向图是一条链： 
 - 一维循环：链表

对于任意问题：
  - 在有状态构成的图上，做一些遍历
  - 如何高效遍历？求解方法的好坏。

### 状态的简化
  - 把可以由其它数据决定的信息从状态中剔除，
  - 得到的最简状态决定了问题的**复杂度**。
对于简单的计票问题：
  - i决定后，counts已经确定。counts对i来说为附加信息。  

### 指数形态的状态空间
- 子集
```c
set = [1, 2, 3]   subset = [[],[1],[2],[3],[1,2],[2,3],[1,3],[1,2,3]]

                             index = 0, subset = []
                           /       第1个数选不选？       \
             index=1,subset=[]                 index=1, subset[1]
               /       \           第2个数选不选？         /         \   
         index=2        index=2                 index=2         index=2
       subset=[]        subset[2]              subset=[1]       subset=[1,2]
       /   \              /   \    第3个数选不选？     /   \               /       \
  index=3 index=3    index=3   index=3       index=3  index=3     index=3     index=3
subset=[] subset[3] subset=[2] subset=[2,3] subset[1] subset[1,3] subset[1,2] subset[1,2,3] 
```
- 注意
  - 子集并不由index决定
  - 状态空间为 `2^n`，指数型
### 排列形态的状态空间
- 全排列
```c
permutations = [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
        
                             p=[]           
            /----------------- | ------------------\      第1个数选哪个？                    
       p=[1]                p=[2]                 p=[3]
     /     \               /     \               /    \   第2个数选哪个？
p=[1,2]   p=[1,3]    p=[2,1]    p=[2,3]    p=[3,1]    p=[3,2]
   |        |              |        |           |      |  第3个数选哪个？
p=[1,2,3] p=[1,3,2]  p=[2,1,3]  p=[2,3,1]  p=[3,1,2]  p[3,2,1]
```
## 搜索
- 搜索其实就是采取蛮力的一种方法
- 搜索就是采用**直接遍历整个状态空间**的方法寻找答案的一类算法。
- 状态空间可以类比为一张图。  
- 根据遍历状态空间的图的类型的不同。
  - 深度优先搜索（DFS，depth first search）
  - 广度优先搜索（BFS，breath frist search）
- 一般来说，每个状态**只遍历一次**。
  - 所以！当状态空间是"**图**"而不是"**树**"时，需要**判重**
    - 判重使用visit数组。（记忆）
### DFS
### BFS
## 实战
- 电话号码的字母组合（Medium）
    - https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/
    - [要点](../week03/in-action/10/README.md)
    - [解法](../week03/in-action/10/letter_combinations_phone_number.cpp)
- N 皇后（Hard）
    - https://leetcode-cn.com/problems/n-queens/
    - [要点](../week03/in-action/11/README.md)
    - [解法](../week03/in-action/11/n_queens.cpp)
- 岛屿数量（Medium）
    - 地图类DFS/BFS，判重，方向数组 (重点)
    - https://leetcode-cn.com/problems/number-of-islands/
    - [要点](../week03/in-action/12/README.md)
    - [解法](../week03/in-action/11/n_queens.cpp)

## 总结
### DFS vs BFS
 - 广搜程序比深搜长。深搜好写
   - 因为深搜其实利用了系统本身的堆栈（函数本身）的数据结构。
   - 而广搜需要使用队列这个数据结构。
 - DFS更适合搜索树型状态空间
   - 递归本身就会产生树的结构
   - 可以使用全局变量维护状态中较为复杂的信息（例：子集、排列）
   - 不需要队列，节省空间（也不用写相关队列的操作的代码）
 - BFS适合最小代价、最小步数的题目
   - BFS是按层次序搜索，第K步走完才走K+1步，在任意时刻队列中至多只有两层。
     - 层次搜索，一层=一步
 - 状态空间为一般的图是（需要判重），DFS和BFS差不多
   - 可按个人喜好。
   - 地图题用广搜可能更舒服。 

