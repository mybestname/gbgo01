# 第 7 课 二叉堆、二叉搜索树 (7.8)

## 二叉堆

### 堆（heap）
- 堆是一种高效维护集合中最大或最小元素的数据结构。
- 大根堆
  - 根节点最大，用于维护和查找max
- 小根堆
  - 根节点最小，用于维护和查找min
- 堆是一棵二叉树 
  - 大根：任意节点满足 父>=子
  - 小根：任意节点满足 父<=子
  
```c
                         110
                        /   \
                    100       90
                   /  \       /  \ 
                40     80    60   20     
               /  \   /  \
            10   30  70  50    
```
   - 两个孩子之间的关系是无所谓的。
     - 可能左>右，也可能右大于左
### 二叉堆 （binary Heap）
- 堆的简易实现
- 本质上是一棵满足 **堆性质** 的 **完全**二叉树
- 常见操作
  - 建堆 build : O(N)
  - 查询最值 get max/min : O(1)
  - 插入 insert : O(logN) 
  - 取出最值 delete max/min : O(logN)
    - 这里取出的意思是，当当获得最值时候同时要删除堆内的最值。类似队列的pop
- 斐波那契堆、配对堆可以做到插入 O（1）
- 左偏树、斜堆等可以支持合并
- 在语言中，一般描述为优先队列（priority queue）
  - C++ priority_queue
  - Java PriorityQueue
  - Python heapq
  - Go https://golang.org/pkg/container/heap/


### 堆和树的区别
- 堆是一棵满足堆性质的特别的树。
- 二叉堆是一棵特殊的二叉树。

### 数据结构堆和堆内存的区别。
- 堆内存和数据结构堆为何都叫 heap
  - 两者没有关系，完全不一样的两个东西。
  - 有可能早期的内存垃圾回收算法使用了优先队列，但没有找到确证。
>
> - Donald Knuth: *The Art of Programming, vo1, 3e*
>   > Several authors began about 1975 to call the pool of available
>   > memory a "heap."  But in the present series of books, we will use
>   > that word only in its more traditional sense related to priority
>   > queues. (Fundamental Algorithms, 3rd ed., p. 435)
> - Thomas H.Cormen: *Introduction to algorithms 1e (1990)*
>   > We note that the term "heap" was originally coined in the context
>   > of heapsort, but it has since come to refer to "garbage-collected
>   > storage," such as the programming language Lisp provides. Our heap
>   > data structure is not garbage-collected storage, and whenever we
>   > refer to heaps in this book, we shall mean the structure defined
>   > in this chapter.
    
### 二叉堆的实现
- 二叉堆一般使用一个二维数组存储。
  - 利用 完全二叉树 的**节点编号**特征。
- **完全**二叉树 
  - 只在右侧缺一些节点。
  - 前 n-1 层都为满,只有第 n 层的左边是满的，只有右侧缺少一些节点
```c
                           110  [0]
                   /--------|--------\
           [1]   100                  90   [2]
               /    \                /  \ 
        [3]  40      80   [4]       60   20 
            /  \     /  \          [5]   [6]
           10  30   70   50
          [7]  [8]  [9]  [10]

 0 * 2 + 1 = 1                      0 * 2 + 2 = 2
 1 * 2 + 1 = 3                      2 * 2 + 2 = 6
 3 * 2 + 1 = 7
                3 = (7-1)/2  3 = (8-1)/2
```
当第一个节点（根节点）存储在 **下标 0** 的情况下
- `father * 2 + 1 = left_child`
- `father * 2 + 2 = right_child`
- `father = (child-1)/2`  

```c
                           110  [1]
                   /--------|--------\
           [2]   100                  90   [3]
               /    \                /  \ 
        [4]  40      80   [5]       60   20 
            /  \     /  \          [6]   [7]
           10  30   70   50
          [8]  [9]  [10]  [11]

 1 * 2 = 2                        0 * 2 + 1 = 3
 2 * 2 = 4                        3 * 2 + 1 = 7
 4 * 2 = 8
               4 = 8/2  4 = 9/2
```
当第一个节点（根节点）存储在 **下标 1** 的情况下
- `father * 2 = left_child`
- `father * 2 + 1 = right_child`
- `father = child/2`  

按照个人习惯选择root存在`[0]`，还是`[1]`
- 存1的情况，主要是有些场景使用 1..n 做为索引去遍历，比较容易思考。

### 插入（insert）
- 新元素一律插入到数组的尾部
  - 设插入到节点p的位置。
- 然后向上进行一次调整。（heapify up）
  - 如果达到根，停止
  - 若满足堆性质 `heap[p] <= heap [p/2]` ，停止 
  - 否则，交换 `heap[p]` 和 `heap[p/2]` , 令 `p = p/2` ，继续调整。  
- 复杂度：O(logN)  
  - logN是树高
  
#### 插入例子
```c
                         110
                        /   \
                    100       90
                   /  \       /  \ 
                40     80    60   20     
               /  \   /  \
            10   30  70  50
            
     插入前的数组       
   [110, 100, 90, 40, 80, 60, 20, 10, 30, 70, 50]         
     0   1    2   3   4   5   6   7   8   9   10  11
   
     插入95，先到尾部。
   [110, 100, 90, 40, 80, 60, 20, 10, 30, 70, 50, 95]    
   
     p = 11,  p/2 = 5
     heap[5] = 60 <= heap [11] = 95, 交换
     
   [110, 100, 90, 40, 80, 95, 20, 10, 30, 70, 50, 60]
   
     p = 5,   p/2 = 2 
     heap[2] = 90 <= heap [5]  = 95, 交换
     
   [110, 100, 95, 40, 80, 90, 20, 10, 30, 70, 50, 60]
     0   1    2   3   4   5   6   7   8   9   10  11

     p = 2,   p/2 = 1
     heap[1] = 100 > heap [2]  = 95, 停止        
   
                 110                            110         
                /   \                          /   \        
            100       90                   100       95      
           /  \       /  \     ---->      /  \       /  \    
        40     80    60   20           40     80    90   20 
       /  \   /  \                    /  \   /  \   /        
    10   30  70  50                10   30  70  50  60      
```

### 取出（extract）
- 把堆顶 `heap[0]` 和堆尾 `heap[n-1]` 交换。 删除堆尾。
- 然后从根向下进行一次调整（heapify down）
  - 每次和左右节点中较大的比较，检查堆性质，不满足则交换
  - 注意判断子节点是否存在。
- 复杂度
  - O(LogN)
  - 树的高度
#### 取出例子

```c
                         110
                        /   \
                    100       90
                   /  \       /  \ 
                40     80    60   20    
               /  \   /  \
            10   30  70  50          
            
     取出前的数组       
   [110, 100, 90, 40, 80, 60, 20, 10, 30, 70, 50]  
     0   1    2   3   4   5   6   7   8   9   10
     
     头尾交换, 删除队尾
   [*50, 100, 90, 40, 80, 60, 20, 10, 30, 70, *110]
   [50, 100, 90, 40, 80, 60, 20, 10, 30, 70]
     0   1    2   3   4   5   6   7   8   9   10 
     p = 0
     heap[0] = 50, heap[0*2+1] = 100, heap [0*2+2] = 90,
     100 > 90, heap[0] 和 heap [1] 交换

   [*100, *50, 90, 40, 80, 60, 20, 10, 30, 70]
     0   1    2   3   4   5   6   7   8   9   10 
     p = 1
     heap [1*2+1] = heap[3] = 40, heap [1*2+2] = heap[4] = 80 
     heap [1] 和 heap [4] 交换
   
   [100, *80, 90, 40, *50, 60, 20, 10, 30, 70]
     0   1    2   3   4   5   6   7   8   9   10 
     p = 4
     heap [4*2+1] = heap[9] = 70，2*2+2 > heap.size()
     heap [4] 和 heap [9] 交换， 
   [100, 80, 90, 40, *70, 60, 20, 10, 30, *50]  
     p = 9， 没有子节点，结束
  
                 110                                100 
                /   \                              /   \
            100       90       ------->        80       90
           /  \       /  \                    /  \       /  \ 
        40     80    60   20               40     70    60   20  
       /  \   /  \                        /  \   /             
    10   30  70  50                    10   30  50             
```

### 优先队列（Priority Queue）
- 支持push
- 支持弹出最值（pop）（基于优先级）  
- 二叉堆是优先队列的一种简单、常见的实现
- 但不是最优实现
- 理论上二叉堆可以支持O(logN)的删除任意元素。
  - 定位该元素在堆中的节点p
     - 可以通过在数值和索引直接建立映射得到O(1)操作
     - 回忆例题：邻值查找、LRU里面用hashmap 
  - 和堆尾交换，删除堆尾
  - 从p向上、向下各进行一次调整。
    - 因为p位置是一个中间值，既有可能向上调整，也可能需要向下调整
    - 二叉堆保证的是从根到每一个孩子的每一条路径都有序。
- 不过优先队列没有提供这个方法（删除任意元素）
- 在各语言的内置库中，需要支持删除任意元素时，一般使用 **有序集合** 等基于 **平衡二叉搜索树** 的实现。

### 二叉堆、优先队列 实战
- 合并 K 个升序链表（Hard）
  - https://leetcode-cn.com/problems/merge-k-sorted-lists/
  - [要点](../week04/in-action/01/README.md)
  - [解法](../week04/in-action/01/merge_k_sorted_lists.cpp)
- 滑动窗口最大值（Hard）
  - https://leetcode-cn.com/problems/sliding-window-maximum/
  - [二叉堆解法的要点](../week04/in-action/02/README.md)
  - [回忆 week01_02的解法](../week01/in-action/18/README.md)

## 二叉搜索树 Binary Search Tree

### 概念
- 二叉搜索树(Binary Search Tree) 是一棵满足BST性质的二叉树
  - 任意节点的key >= 它的左子树中所有节点的key
  - 任意节点的key <= 它的右子树中所有节点的key
  - 所以，二叉搜索树的中序遍历（左根右）必然为一个有序序列。
    
```c
                        27
                     /     \ 
                  14          35 
                /   \       /   \
              10     19    31    42     
              
    
   10 <= 14 <= 19 ;  31 <= 35 <= 42
   (10,14,19) <= 27 <= (31, 35, 42)
```
  - 时间复杂度 树高，logN，但注意树高不能保证。
  - 一般的二叉搜索树用的并不多，因为有退化的情况。

### BST建立
- 为了避免越界，减少边界情况的特殊判断，一般在BST中额外插入两个保护点
  - 一个key为正无穷（一个很大的正整数）
  - 一个key为负无穷
    ```c
        ------
       |_+inf_| 
          |
          |   
        --V---
       |_-inf_|
             
    仅有两个保护节点构成的BST就是一棵初始为空的BST
    ```

### BST 检索
- 检索key的val是否存在
- 从根开始递归查找
  - 若当前节点的key > val，递归检索左子树（或不存在）
  - 若当前节点的key < val，递归检索右子树（或不存在）

```c
         5                                 5
        /  \                              /  \
      2     9                           2     9
     /      /  \                       / ?   /  \
   -inf    6   +inf                  -inf    6   +inf
     \                                 \
      1                                 1

    查找6                              查找3 ：不存在
    5 (r) -> 9 (l) -> 6               5 (l) -> 2(r) -> 存在
```  


- 退化，退化为链表，那么查找 1 等于 `O(N)`
   - 层高为 `N`，而不是 `logN` 了。
   - 因为树高并没有保证。
   - 这种是不平衡的BST，真实情况下，语言标准库提供的都是自平衡的BST。
```c
              4
             /
           3
          / 
        2
       / 
     1   
```
- 重复点的问题
  - 如果需要插入相同的元素，那么可以用记录副本数量的方式解决。
  - 即每个节点还有一个辅助属性 cnt（副本数），记录节点的数量。
  
### BST 插入
- 插入和检索很类似
  - 如检索 val 发现存在，则放弃插入（或把副本数 +1 ，根据需求来定）
  - 如果检索 val 发现不存在（子树为空），直接在对应位置新建节点 ( key = val ）

```c
              5                                  
           /     \                                  
         2         9                                  
       /  \       /  \                                 
   -inf   (3)    6   +inf                                  
     \            \                            
      1           (8)
      
   插入3和8
   insert 3 -> find 3 -> 5.l -> 2.r -> nullptr, 2.r -> (3)         
   insert 8 -> find 8 -> 5.r -> 9.l -> 6.r -> nullptr, 6.r -> (8) 
```        

### BST 求前驱和后继
- 前驱：BST中小于 val 的节点
- 后继：BST中大于 val 的节点
- 求前驱、后继也是基于检索，先检索 val
- 以求后继为例
  - 如果发现 val，并且 val 存在 右子树，则在 **右子树中 一直向左走到底**。
  - 否则，没有找到 val 或者 val 没有 右子树，说明 后继在从根到当前已经走过的节点中。
     - 即当前节点的所有祖先节点中。
     - 可以拿一个变量顺便求一下。
- 复杂度 `O（树高）`，期望为`O(logN)`，退化为`O(N)`  

1.) 求 5 的后继
```c
         5               - find 5 -> 存在 -> 5.r 存在 -> 9
       /   \             - 右子树一直向左走到底 
      2      9              -> 6 -> 6.r = nullptr 结束
     / \    /  \         - 得到 5 的后继为 6  
 -inf   3  6   +inf           
     \      \       
      1      8
```
2.) 求 3 的后继
```c
          5             - find 3 -> 存在
        /   \           - 3.r -> 不存在
      2      9            - 如果根不存在r，则没有后继
     / \    /  \          - 如果根存在，那么是存在后继的
 -inf   3  6   +inf       - 后继除了出现在右子树中还可能存在于从根到3的点上
     \      \           
      1      8         
```
    
### BST 删除
- 从 BST 中删除 key 为 val 的节点，可以基于 **检索 + 求后继** 实现。
- 首先检索 val
  - 如果 val 只有一颗子树，直接删除val，再把子树和父节点相连即可。
  - 如果 val 有两棵子树，需要找到后继，先删除后继， 然后再用 后继节点 代替 val 的位置。
    - 这种情况：后继是右子树一直走到底，所有最多只会有一棵子树。
- 也可以用 检索 + 求前驱 的方法，这里不再赘述。    

1.) 删除 5 
```c
          5                             6                
        /   \                         /   \          
      2      9                      2      9         
     / \    /  \                   / \    /  \       
 -inf   3  6   +inf            -inf   3  8   +inf    
     \      \                      \                
      1      8                      1               

 - find 5 找到 -> 5 有 两棵子树，需要找后继。
 - 找到后继 6
 - 删除 6 
   -  8 代替了 6
 - 用 6 替换 5 
   - 删除 5
   - 6 代替 5
   - 6.r 8 代替 6
```  


### BST 实战


                
        



        