## 23. 合并K个升序链表
- https://leetcode-cn.com/problems/merge-k-sorted-lists/
- https://leetcode.com/problems/merge-k-sorted-lists/
- 给你一个链表数组，每个链表都 **已经 按升序 排列**。
- 请你将所有链表合并到一个升序链表中，返回合并后的链表。

```
示例 1：

输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
1->4->5,
1->3->4,
2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```
```
示例 2：

输入：lists = []
输出：[]
```
```
示例 3：

输入：lists = [[]]
输出：[]
```

### 思路
- 第2周 作业5 出现过，要求使用分治实现
- 这里要求使用堆来实现
- 两个链表的合并，使用两个指针，指向头部，谁放进来。
- 暴力法合并k个链表。两个两个合并，`(((1,2),3),4)....n)`
  - 1，2 -> O(N)  2N长度
  - 1+2，3 ->     3N长度
  ..              kN长度
  - 时间复杂度 `n + 2n + 3n ... + kn` = `n(1..k)`  ->  `O( k^2 * N )`  
- 分治法合并k个链表
  - 分成 2 个子问题，第一个解决前 k/2 个队列，第二个解决后 k/2 个队列。
  - `O(kN * logk)` 一共kN个数（每层kN个元素），logk层（二分）
- 堆的解法：
  - k个升序链表合并，等于开k个指针，比较k个数的大小，
    即一个k的集合找最小值。然后把最小值放入答案链表。
  - 也就是由两个比大小，变为了k个比大小。  
  - 使用heap，比较为logk
  - 那么`O(logk*kN)`,和分治的复杂度相同。
  