## 239. 滑动窗口最大值
- https://leetcode-cn.com/problems/sliding-window-maximum/
- https://leetcode.com/problems/sliding-window-maximum/
- 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。
  - 你只可以看到在滑动窗口内的 k 个数字。
  - 滑动窗口每次只向右移动一位。
- 返回滑动窗口中的最大值。


```
示例 1：

输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]

解释：

滑动窗口的位置                   最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
1  [3  -1  -3] 5  3  6  7       3
1   3 [-1  -3  5] 3  6  7       5
1   3  -1 [-3  5  3] 6  7       5
1   3  -1  -3 [5  3  6] 7       6
1   3  -1  -3  5 [3  6  7]      7
```
```
示例 2：

输入：nums = [1], k = 1
输出：[1]
```
```
示例 3：

输入：nums = [1,-1], k = 1
输出：[1,-1]
```
```
示例 4：

输入：nums = [9,11], k = 2
输出：[11]
```
```
示例 5：

输入：nums = [4,-2], k = 2
输出：[4]
```
### 思路

- 对比单调队列的解法和堆的解法
 - 有了堆的数据结构的支持，那么这道题变得简单。
- 本质：一个集合，需要插入一个数，同时删除一个数，然后维护极值。
  - 数据结构：需要支持插入，删除，查询最值。
    - 有序集合（第3课）多重集合mutilset（平衡树实现）。Java的TreeSet
    - 堆（本题要求用堆实现）
       - 要么手写二叉堆，同时支持删除任意元素。
       - 优先队列只能删除最大值，不支持删除指定下标元素。
          - 使用 lazy delete 惰性删除法
              - 指从堆中删除元素时候不直接删除，而是打一个删除标记（软删除）
              - 等未来它做为最大值删除时，看是否被标记过。
          - 只要需要被删除的元素不影响结果最大值，那么在堆中多待一些时间是无所谓的。
            未来等它影响结果最大值正确性的时候再说。  
- lazy delete示例
```
heap_ _ 滑动窗[...]                 最大值  h.top
-------------------------------    ----- ------
[1   3  -1] -3   5   3   6   7     3     3
_1  [3  -1  -3]_ 5   3   6   7     3     3    结果不变，heap.size > 滑动窗
_1   3 [-1  -3   5]_ 3   6   7     5     5    结果不变
_1   3  -1 [-3   5   3]_ 6   7     5     5    结果不变
_1   3  -1  -3  [5   3   6]_ 7     6     6    结果不变
_1   3  -1  -3   5  [3   6   7]_   7     7    结果不变

heap_ _ 滑动窗[...]                 最大值  h.top
-------------------------------    ----- ------
[1   3  -1] -3   2   3   6   7     3     3
_1  [3  -1  -3]_ 2   3   6   7     3     3    结果不变，heap.size > 滑动窗
_1   3 [-1  -3   2]_ 3   6   7     2     3    结果错误！按滑动窗应为2
_1   3  -1 [-3   2   3]_ 6   7     3     3    结果不变 
_1   3  -1  -3  [2   3   6]_ 7     6     6    结果不变 
_1   3  -1  -3   2  [3   6   7]_   7     7    结果不变

结论：
- 3这个老值对答案产生了影响。
- 如果我们存在heap中的不止有值还有下标：
  - 那么heap当时的情况如下
_(1,0) (3,1) [(-1,2) (-3,3) (2,4)]_ 

那么当获得(3,1)这个最大值时候，
我们同时检查一下，3这个结果是否合法，如果不合法则抛弃掉（pop掉）。
  - 如何检查是否合法？
    - 看是否在滑动窗口中。(3,1)中的1表示下标为1，而当前游标已经为4，
    - 说明4-1=3，已经等于滑动窗口的大小，说明已经不合法了，需要pop掉。
当pop掉(3,1)后，heep的top就会获得正确的结果(2,4)。

这样所谓的lazy delete，就是一个加了条件判断的pop操作
根据合法性判断来pop掉当前heap的极大值，只有非法的极大值才pop掉
这样就不是插入（push）和删除的1：1操作了，
而是每一次插入，可能删也可能不删，根据条件去删除（pop）。
这样删除就延迟了，
```  