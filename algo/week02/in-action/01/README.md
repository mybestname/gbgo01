## 874. 模拟行走机器人
- https://leetcode-cn.com/problems/walking-robot-simulation/
- https://leetcode.com/problems/walking-robot-simulation/
- 机器人在一个无限大小的 XY 网格平面上行走，从点 (0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令 commands ：
  - -2 ：向左转 90 度
  - -1 ：向右转 90 度
  - 1 <= x <= 9 ：向前移动 x 个单位长度
- 在网格上有一些格子被视为障碍物 obstacles 。
  - 第 i 个障碍物位于网格点  obstacles[i] = (xi, yi) 。
- 机器人无法走到障碍物上，它将会停留在障碍物的前一个网格方块上，但仍然可以
  继续尝试进行该路线的其余部分。
- 返回从原点到机器人所有经过的路径点（坐标为整数）的最大欧式距离的平方。
  （即，如果距离为 5 ，则返回 25 ）


注意：
- 北表示 +Y 方向。
- 东表示 +X 方向。
- 南表示 -Y 方向。
- 西表示 -X 方向。

```
示例 1：

输入：commands = [4,-1,3], obstacles = []
输出：25
解释：
机器人开始位于 (0, 0)：
1. 向北移动 4 个单位，到达 (0, 4)
2. 右转
3. 向东移动 3 个单位，到达 (3, 4)
   距离原点最远的是 (3, 4) ，距离为 3^2 + 4^2 = 25
     
      4 B(0,4)  C(3,4) 
      3      
      2  
      1  
   (0,0)A -  -  -  -  -  -    
          1  2  3  4  5
          
     Eu-Dis = AB^2 + BC^2 = 25     
```
```
示例 2：

输入：commands = [4,-1,4,-2,4], obstacles = [[2,4]]
输出：65
解释：机器人开始位于 (0, 0)：
1. 向北移动 4 个单位，到达 (0, 4)
2. 右转
3. 向东移动 1 个单位，然后被位于 (2, 4) 的障碍物阻挡，机器人停在 (1, 4)
4. 左转
5. 向北走 4 个单位，到达 (1, 8)
   距离原点最远的是 (1, 8) ，距离为 1^2 + 8^2 = 65
         (1,8)
      8   d
      7    
      6    
      5  (1,4) 
(0,4) 4 b c o(2,4) 
      3     
      2  
      1  
   (0,0)a -  -  -  -  -  -  -  - 
          1  2  3  4  5  6  7  8  
   Eu-Dis(d) = 1^2+8^2 
```

### 思路
- 使用set或map存储障碍物，从而快速检测一个格子有没有障碍
- 可以使用方向数组来按方向行走
```
        //           N, E,  S,  W
        int dx[4] = {0, 1,  0, -1 };
        int dy[4] = {1, 0, -1,  0 };
        // dir=0 N; dir=1 E; dir=2 S; dir=3 W 
        int dir = 0; 
        next_x = x + dx[dir];
        next_y = y + dy[dir];
```

