# 第 0 课（6月16日）

## 数据驱动算法
按顺序
- 线性数据结构：相应算法
- 树、图 ：递归、搜索
- 集合、维度、状态空间 ：动态规划等
## 三个主线 + 两个副本
20节课=16（三主线）+ 4（两副本）
10大类/35小类/5-7例题

### 三个主线（线性、树型、状态空间）
线性
```
数组、链表、栈、队列 
     -> 前缀和、差分、双指针、滑动窗口 
         -> hashmap、集合、映射 
             -> 字符串 
```
树型
```
递归、分治 -> 树、图 -> 搜索 -> 堆、二叉树 -> 字典树、并查集 -> 图论算法
```
状态空间
```
                     搜索  ->  贪心  ->   动态规划      -> 图论算法
```

### 两个副本 （顺序优化、高级数据结构）
- 顺序优化：```排序、二分```
- 高级数据结构：```平衡树、跳表、树状数组、线段树```

## 思路
### 解决怎么想到
情景 问题模型化 知识点 实战（思路+直播代码）

### 找准定位
目标vs时间
```
       时间   课   回顾    练习     强化   目标 
-------------------------------------------------------             
1. 高  300h = 2h + 1h   + 7h   + 100h   打击算法面试
2. 中  200h = 2h + 1h   + 5h   + 40h    算法面试基本ok
3. 低  120h = 2h + 0.5h + 3.5h (2/5题)  做对中等题，难题有思考
4. 最   80h = 2h +      + 2h            对算法有基本认知
```

### 掌握方法

- 课前预习（**非常重要**）
    - 浏览ppt，标注不懂点
    - 每知识点选1道例题，看题意，自己思考
- 课上
    - 注意思路，不要盯细节，等回放
    - 算法和数据结构复杂、60/70%理解ok
    - 每节课有2个知识点（一共35小类），5-7例题。内容多，时间短，15min每题。
- 复习
    - 只回放重点、不理解。1.5~2倍 回放
    - 实践，发现问题及时提问。

### 避免误区（3个）
- 误区1：对刷题题解的两个极端
    - 只看题解：学而不思
    - 只自己死抠：思而不学
    - 正确做法：需要兼顾，平衡：学vs思
- 误区2：LeeCode 每题一遍，随机刷题）
    - 正确做法：分类三刷：（三刷五步刷题法）
- 误区3：解题时：拿学过算法挨个试
    - 正确做法：坚持五步刷题：
        - ```剖析关键 -> 回想模型 -> 识别特征找算法```
        - 题目特征驱动算法（不要猜测算法试解）

三刷
```
初学分类刷 vs. 后期综合刷
一刷：
  - 每个小类型，精调经典题，各刷几道
  - 此时看题解，正常
二刷：
  - 复习代表题目
  - 小类别 -> 大类别
  - 大量刷该分类的题目，举一反三。
  - 尽量少的提示
三刷：
  - 综合性题目
  - 独立实现 + 测试    
```
五步
```
第一步：理解题面
  - 想一想更多例子和测试数据，看是否有遗漏
  - 提炼关键信息，变化信息
  - 面试：跟面试官确认自己的理解
第二步：部分实现
  - 先尝试实现一个朴素算法
  - 或部分场景解法
  - 再优化解法，覆盖更多场景。
第三步：有提示解答
  - 看提示 != 看题解
  - 可以看部分题解，看是否能找到突破口
  - 重点：什么类别、题解标题、时间复杂度、结论
  - 面试： 有效交流以获得适当提示，理解面试官试图引导你什么？     
第四步：独立解答
  - 独立完成解答，同时注意测试
  - 初期训练可以搜索出发
    - 搜索时候关注了那些信息
    - 冗余？是否更好维护
    - 是否有同类的问题。
第五步：写题解
  - 尝试给别人讲（模拟面试讲解），尝试分析不同解法的优劣。
  - 可使用日志形式，记录难点。
  - 回看，迭代自己的题解，快速复习的过程。
```

#### 五步法的一次示例

- 题目：给定有序n二元组(x1,y1),(x2,y2),...,(xn,yn), 已经按x从小到大进行排序。
  求：y_i + y_j + | x_i - x_j | 的最大值 (i != j)。
- 五步法
    - 步1：理解题面
        - 有序，i != j， 绝对值的概念。
    - 步2-1：朴素实现：O(n^2)
      ```c++
      for (int i = 1, i < n; i++) {
          for (int j = 1, j < n; j++) {
              if ( i!= j) 
                  ans = max(ans, y[i] + y[j] + abs (x[i] - x [j]));
          }
      }
      ```
    - 步2-2：优化
        - 问题：朴素解法中那些是冗余的？
        - 优化1：
            - 朴素解答的i和j的顺序是无关的，但其实i和j一定有序
                - 朴素的**循环多冗余了一倍**
                    - 如i>j，则多了所有i<j的部分。如果i<j，则多了所有i>j的部分，所有正好多了一倍。
                - 没有利用上x已经从小到大排序好这个概念。
                    - **`abs`是冗余的**
            - 那么循环怎么改？j在i的后面，不好控制，如果换一下。设i>j，即 1<=j<i<=n，
              可以看出谁是i，谁是j不重要，关键是谁是内层循环，谁是外层循环。
          ```c++
          for (int i = 2; i < n; i++ ) {
            for (int j = 1; j < i; j++) {
               if ( i != j)
                   ans = max(ans, y[i]+y[j]+x[i]-x[j]); 
            }
          }
          ```  
        - 优化2：是否还有冗余？
            - `y[i]+x[i]`部分，这个和内层循环是无关的（不变），内层循环变化的只是`y[j]-x[j]`部分
          ```c++
          for (int i = 2; i < n ; i++ ) {
            inner = 0;
            for (int j = 1; j < i; j++ ) {
                if (i != j)
                    inner = max(inner, y[j]-x[j]);
            }
            ans = max(ans, y[i]+x[i]+inner);
          }
          ```
        - 优化3：优化2没有什么实质的改变，还是O(n^2)，陷入瓶颈。
            - 进行模拟执行，观察
          ```
          i=2, j=1,      inner_2 = max(y1-x1);
          i=3, j=1,2,    inner_3 = max(y2-x2); 2 = max(y1-x1)                  => inner_3 = max (y2-x2, y1-x1)
          i=4, j=1,2,3   inner_4 = max(y3-x3); 3 = max(y2-x2); 2 = max(y1-x1); => inner_4 = max (y3-x3, y2-x2, y1-x1)
          ```
            - 可以看出，max运算中含有大量冗余，后面计算并没有利用到前面的结果，而是进行了重复计算。
            - 对于每个i，inner_i = max (inner_(i-1), y_(i-1) - x_(i-1))
          ```c++
          for (int i=2; i<n; i++) {
            inner = max(inner, y[i-1]-x[i-1]);
            ans = max(ans, y[i]+x[i]+ inner);
          }
          ```
            - 这个优化实现了质的飞跃，变为O(n)了

> - 所谓的五步，这里只展示了前两步。
> - 五步是如何刷题，前两步是如何解题
> - 模拟执行是一种常见办法。
- 发散思考
    - 和图像/图形、数据结构相联系
      ```
                       y2   
               y1      |
               |       |       y3
               |       |       |
          -----x1 -----x2 -----x3 ------>
      
      坐标系 => 树/叶子节点 => 树上某两个叶子节点间的最远距离（树的直径问题）
      
                   x1
                 /  \ 
                y1   x2
                   /  \
                  y2   x3
                      / ...
                    y3
      ```
    - x是树的主干、y是树的分支
    - 其实是求树的直径
- 这个题变为动态优化问题
- 算法必须和数据结构相结合
- 数据在驱动算法

## 时空复杂度分析方法
### 大O表示法
- `O(1)` 常量 constant complexity
- `O(log(n))` 对数 logarithmic complexity
- `O(n)` 线性 liner complexity 顺序查找n的列表
- `nO(log(n))` n-log-n, 许多分治算法，包括合并排序和快速排序
- `O(n^2)` 平方 square complexity  两重嵌套循环: 基本排序算法和n阶方阵
- `O(n^3)` 立方 cubic complexity   三重嵌套循环: 线性代数
- `O(2^n)` 指数 exponential complexity 求n个元素集合的所有子集
- `O(n!)` 阶乘 factorial complexity  求n个元素集合的完全排列

### O Ω Θ
- Ο是渐进上界，Ω是渐进下界。Θ需同时满足大Ο和Ω，故称为确界（必须同时符合上界和下界）。
- Ο最有用，表示了最差性能。

**注意：列表也是复杂度的排序**

#### 为什么`O(log(n))`没有底数
- 对数之间是可以互相转换的
- 有底数的对数可以转为常量*另外底数的对数，所以简化起见忽略底数，直接表示为O(log(n))

#### 典型示例

`O(log(n))`
```c
for (int i = 1; i< n; i = i * 2) {
  //执行了多少次？ (i = i *2) < n 即 2^x= n 即 x = log(n)
}
```

`O(nlog(n))`  分治算法
```c
void calc (int l, int r) {
   if ( l > r ) return; 
   for (int i = l; i <= r; i++) { 
       /* do real stuff .. */ 
   }
   int mid = (l + r) / 2;
   calc (l, mid);
   calc (mid + 1, r);
}
calc(1, n); 
```
```
        aaaaaaaabbbbbbbb           每层分一半，问一共有多少层。
       aaaaaaaa  bbbbbbbb          设x层。 则2^x = n 
      aaaa aaaa  bbbb  bbbb        x = log(n)
    aa aa aa aa  bb bb bb bb 
              ...
                                   每次执行n次
                                   则一共执行 n*层数
                                   所以 n*log(n)
```

`O(k^n)` 递归求fib 指数级别
```c
int fib (int n) {
  if (n < 2 ) return n;
  return fib(n-1) + fib(n-2);
}
```
```
f(n) = f(n-1) + f(n-2)
     < f(n-1) + f(n-1) 
     < 2*f(n-1)
     < 2*2*f(n-2)
     < 2*2*2*f(n-3)
     < ...
     < 2^n*f(n-n) = 2^n => Big(o) = O(2^n)
or

f(n) = f(n-1)+f(n-2)
     = f(n-2)+f(n-3)+f(n-2)        = 2*f(n-2) + f(n-3)
     = 2*(f(n-3)+f(n-4))+f(n-3)    = 2*2*f(n-3) + 2*f(n-4)     
     = 2*2*(f(n-4)+f(n-5)+2*f(n-4) = 2*2*2*f(n-4) + 2*2*f(n-5)
     = ... = 
     
     
精确: 
k^n = k^(n-1) + k^(n-2) 求k
k^n/k^(n-2) = k^(n-1)/k^(n-2) + k^(n-2)/k^(n-2)
k^2 = k + 1
k = (1+sqrt(5))/2 = 1.618 (黄金分割率）
O（1.6^n)
```

`O(n!)`
```c
const int N = 13;
int d[N];// Record Solution
int v[N];// mark whether a value is traversed, not traversed is 0, 1 traversed
int n;
void dfs(int depth) {
    if (depth == N) return;
    for (int i = 0 ; i < n; i++) {
        if (v[i]) continue; 
        v[i] = 1;
        d[depth] = i;
        dfs(depth + 1); 
        v[i] = 0;
    }
}
dfs(0)
```
```
n*(n-1)*(n-2)*...*1 = n!
```

#### BigO与常见公式(数列/级数)

O(n^2)
```
1+2+3+...+n = n*(n+1)/2 
```

O(n)
```
n+n/2+n/4+...+1 < 2n
```

O(log(n))
```
1+1/2+1/3+...+1/n （调和级数）Harmonic  log(n+1) < x < 1 + log(n))
```

#### 最坏和均摊

```c
for (int i=1,j=1,sum=0; i <=n; i++) {
    while (j <= n && sum + a[j] <= T) sum += a[j++];
    sum -= a[i];
}
```
- j从1开始，j是不还原，只增加。i从1到n的过程中，j也从i增长到n，只不过j增长的速度和i不同。
- `sum+a[j]<=T`只是一个j增长的额外限制条件。
- 对于每个i，内层最坏O(n)，均摊O(1)
    - 当T很大时候，可能j需要从1增长到n（最坏），即i=1时，j直接增到n
    - 但是均摊下来(i=1,i=2,..,i=n)，因为j最多只能增到n，n/n，均摊是O(1)
- 所以整个最坏O(n)

vs.

```c
for (int i=1; i <=n; i++) {
    int j=i, sum=0;
    while (j <= n && sum + a[j] <= T) sum += a[j++];
}
```
- j总是从i开始，每次都还原。
- `sum+a[j]<=T`和`j<=n`都受到i的影响。
- 最坏的情况，T很大，使得内层对每个i都是O(n)，和外层结合，整体最坏变为O(n^2)

### 空间复杂度
- 静态数组的长度
- 递归的深度（栈上消耗的空间）
    - Linux：8MB
- 动态new的空间（堆上消耗的空间）
    - Linux：和系统内存同级
