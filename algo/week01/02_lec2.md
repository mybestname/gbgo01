# 第 2 课 前缀和、差分、双指针扫描（6月19日） 

## 前缀和、差分思想

### 前缀和概念
A为一维数组，S为A的前缀和数组
```
S[i] = A[1] + A[2] + ... + A[i]  
S[i] = S[i-1] + A[i]

例子：
A = [0,1,2,1,3,2]
S = [0,1,3,4,7,9]
```

### 前缀和作用
- 求子段和（A中第l个数，到第r个数的和）`sum(a[l:r])`，则可方便的使用S获得
  - `sum(A[l:r] = S[r]-S[l-1]`
    ```
      S[r] = A[0]+...+A[r]
      S[l-1] = A[0]+...+A[l-1]
      S[r]-S[l-1] = A[l]+...+A[r]
    ```
  - 这样一个O(n)的运算，变为了O(1)的运算。
  - 归纳：`子段和 = 两个前缀和相减`

### 二维前缀和
- 二维数组A
- 前缀和数组S (二维数组)
```
S[i][j] = A[1][1]+A[1][2]+...+A[i]A[j] 
        = S[i-1][j]+S[i][j-1]-S[i-1][j-1]+A[i][j]
```

公式可以考虑为一个被分割为四块儿的矩形
```
  (1,1) * - - - - - - - - - - - - - - - - * * (i,1)
        +                         (i-1,1) + +              
        +                                 + +
        +                                 + +
        +                                 + +
        +                                 + +
        +                                 + +
        +                                 + +
        +                       (i-1,j-1) + +   
(1,j-1) * - - - - - - - - - - - - - - - - * * (i,j-1)
  (1,j) * - - - - - - - - - - - - - - - - * * (i,j)  
                                  (i-1,j)     
```
可以理解为：`ABCD = AB+AC-A+D`
```
     ABCD      =       AB        +      AC       -       A       +  D                             
* * * * * * *     * * * * * * *     * * * * * *     * * * * * *                  
*         * *     *         * *     *         *     *         *                  
*         * *  =  *         * *  +  *         *  -  *         *  +                 
* * * * * * *     * * * * * * *     * * * * * *     * * * * * *    * *
* * * * * * *                       * * * * * *                    * *
```



- 可以用来求子矩阵和
  - 以 `(p,q)` 为左上角，`(i,j)` 为右下角的A的 子矩阵 中数的和。
```
sum(p,q,i,j) = A[p]A[q]+...+A[i]A[j] 
             = S[i][j]-S[i][q-1]-S[p-1][j]+S[p-1][q-1]
```  

可以理解为：`D = ABCD - AB - AC + A`
```
* * * * * * *     * * * * * * *     * * * * * *     * * * * * *                  
*         * *     *         * *     *         *     *         *                  
*         * *  -  *         * *  -  *         *  +  *         *  =                 
* * * * * * *     * * * * * * *     * * * * * *     * * * * * *    * *
* * * * * * *                       * * * * * *                    * *
```
#### 时间复杂度
- 预处理 `O(n^2)`
- 查询 `O(1)` (普通暴力的话是`O(n^2)`,两重循环)

### 差分
- 一维数组 A
- 差分数组 B
- 其中 `B_(1) = A_(1)，B_(i) = A_(i) - A_(i-1) (2 <=  i <= n)`
```
A = [ ?,  1 , 2 , 1 , 3 , 2 ]

(2 <= i <= n)
B(1) = A(1) = 1
B(2) = A(2) - A(1) = 2 - 1 = 1 
B = [ ? , 1, 1, -1, 2, -1 ] 
```
- 差分和前缀和是互逆运算
```
A =  0 [ 1, 2, 1, 3, 2]
S =[ 0,  1, 3, 4, 7, 9]

对前缀和S求差分得原数组：
B[1] = S[1]
B[2] = S[2]-S[1] ...
B = 0 [ 1, 2, 1, 3, 2 ]　得到原数组A

对差分数组B求前缀和得到原数组：
B = [ 0 , 1, 1, -1, 2, -1 ] 
S = [ 1, 2, 1, 3, 2 ] = A
```

### 作用
- 前缀和适用于查询操作（不修改）
- 而差分适用于修改操作
- 例如：对原数组的l到r，每个元素加d。
  - 等效针对差分数组操作 B[l] += d; B[r+1] -= d，然后再对差分取前缀和，即得原数组。
  - 等于把一个`O(m*n)`的复杂度变为`O(2m+n)`的复杂度
  
```
例：把2到4，都+1，再把1到4，都减2。
  A  =  0  [  1,  2,  1,  3,  2 ]     
                 +1  +1  +1  
             -2  -2  -2  -2
  A' =  0  [ -1,  1,  0,  2,  2 ]      暴力方法             
                                    vs.         
  B  =  0  [  1,  1, -1,  2, -1 ]      使用差分数组
                 +1          -1 
           +(-2)           -(-2) 
        0  [ -1,  2, -1,  2,  0 ]
S(B) =  0  [ -1,  1,  0,  2,  2 ]  = A`           

```

### 实际应用
对于n*m个元素的更新操作，变为2m个。
例如对于航班订票的统计：从第l到第r的座位被订位。
对于一段的操作的快速维护。


## 双指针扫描、滑动窗口
- 依然是用于解决"子段"的统计问题
- 子段指数组中连续的一段，下标范围为一个闭区间。
- 暴力法都是双循环枚举，枚举左端点l，右端点r（l<=r)
- 需要找到枚举中的冗余部分，将其去除。

优化策略
- 固定右端点，看左端点的取值范围。
  - 例如：**左端点的取值范围是一个前缀**，可以用"前缀和"等算法维护前缀信息。
- 移动一个端点，看另外一个端点的变化情况
  - 例如：**一个端点跟着另一个端点单调移动**，像"滑动窗口"意义，即可用"双指针扫描法"解决。
  - 平行移动
  - 相向移动

## 单调栈、单调队列
### 单调栈题目解题思路：
- 确定递增递减：考虑**前面不能影响后面**的条件
- 代码套路
   ```
   for 每个元素 {
     while（栈顶与新元素不满足单调性）{
       弹栈
       更新答案
     }
     入栈
   }
   ```
  
- 对于单调栈问题，需要特别注意stack的清空条件。以避免stack中还有元素没有计算
  - 计算部分是在出栈时候（不满足单调性的情况）
  - 入栈过程等于数据准备（满足单调性的情况）

### 单调队列解题思路（时间上也有单调性）
- 维护一个候选集合，前面的比较旧，后面的比较新 （**时间上有单调性**）
- 候选项的**某个属性也具有单调性**
- 确定递增递减的方法：考虑任意两个候选项j1< j2 写出j1比j2优的条件
- 排除冗余的关键
  - 若j1比j2差，同时j1的生命周期比j2短，那么j1属于冗余，可以直接清除。
- 代码套路  
  ```
  for 每个元素 {
    while (队头过期）                (1)
      队头出队
    取队头为最佳选项，计算答案          (2)
    while (队尾与新元素不满足单调性）   (3)
      队尾出队
    新元素入队                       (4)
  }
  (3)(4)的顺序（先入队，还是先出队尾）取决于i是不是候选项
  ```