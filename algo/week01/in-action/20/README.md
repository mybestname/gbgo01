## ACWING 136. 邻值查找
- https://www.acwing.com/problem/content/description/138/

- 给定一个长度为 n 的序列 A，A 中的数各不相同。
- 对于 A 中的每一个数 Ai，求： (1≤j<i) `min|Ai−Aj|`
- 以及令上式取到最小值的 j（记为 Pi）。若最小值点不唯一，则选择使 Aj 较小的那个。
- 输入格式
  - 第一行输入整数 n，代表序列长度。
  - 第二行输入 n 个整数A1…An,代表序列的具体数值，数值之间用空格隔开。
- 输出格式
  - 输出共 n−1 行，每行输出两个整数，数值之间用空格隔开。
  - 分别表示当 i 取 2∼n 时，对应的 (1≤j<i) `min|Ai−Aj|` 和 Pi 的值。

```
输入样例：
3
1 5 3
输出样例：
4 1
2 1

解释:
5的邻值为1，
3前面1，5两个数，1，3距离相差2，5和3也差2，两者一样，取元素较小值，所以3的邻值为1

1 5 3 6
6前面3个数1,5,3，6和1差5，6和5差1，6和3差3，显然6和5差值最小，所以6的邻值为5。
```
### 思路
- 有序集合/平衡树/treeSet的思路（暂时放过）
- 链表的思路
  - 根据值有一个排序的双向链表
  - 那么就可以O(1)的得到前驱和后继
    - 前驱和后继是树的概念
      - 前驱指所有值小于该元素的集合中最大的那个。
      - 后继值所有值大于该元素的的集合中最小的那个。
  - 但是需要注意，本题不止有值大小的顺序，还有时间顺序（即下标顺序）。
  
```
考虑例子：
1 8 5 7 3 6

首先建立值排序链表
1 3 5 6 7 8

从6开始看，6的前驱和后继为5，7，5是邻值。
把6删除，链表变为：
1 3 5 7 8 
从3开始看，3为1，5，1为邻值。
把3删除：1 5 7 8
从7开始看，5，8，8为例值
把7删除：1 5 8
从5开始，邻值为8
把5删除：1 8，8的邻值为1 
```
- 读取和存储的优化：
```
初始化：
a  0 [ 1 8 5 7 3 6 ]
rk 0 [ 1 2 3 4 5 6 ]

将 rk 进行按a[i]值排序得到：
a  0 [ 1 8 5 7 3 6 ]
rk 0 [ 1 5 3 6 4 2 ]    

使用rk数组存放排序的结果，这样同样的索引可以灵活的变为，
按位置取值或者按排序取值。 i -> rk[i] 建立了map        

a[rk[i]] [ 1 3 5 6 7 8 ] 可以取排序的结果
    a[i] [ 1 8 5 7 3 6 ] 可取原有位置的结果
```
> 把下标一起排是常见思路：复习在"两数之和"中的使用
> - [week01/in-action/15/two_sum.cpp](../15/two_sum.cpp)

### 关键点
- "索引"的灵活性 - 按下标/按值，即可能是值，也可能是时间。
- 数组和链表之间建立一个值和位置的映射关系
  - 数组是以时间为顺序的
  - 而链表是以值为顺序的
- 倒序去考虑问题。