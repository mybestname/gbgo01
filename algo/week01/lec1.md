# 第1课 数组、链表、栈、队列（6月17日）

## 数组
```
   C++ : int a[100];
  Java : int[] a = new int[100];
Python : a = []
```
### 基础知识 
- 特点：支持随机访问（O(1)的访问时间）
- 关键：索引和寻址
```
        C++ : a[i], *(a+1);
Java/Python : a[i]
```
- 底层：数组在内存中是一段连续的存储空间
- 插入，删除：O（n）
- 追加（append，push back）：O（1）
- prepend(push front): O(n)

### 变长数组
```
  C++  : vector
  Java : ArrayList
Python : list
```

如何实现？
 - 索引和随机访问，如何支持？
 - 初始化分配多长的连续空间？
 - 空间不够，如何自动增长？
 - 空间剩余，如何自动回收？

#### 关于变长数组的思考
- Q: 假设空间不够，自动扩容2倍，那么需要拷贝数据到新空间，并释放旧空间
  - 解释：因为数组必须保持内存连续，所以如果后面的空间不够1倍，
    那么就无法直接从当前内存地址扩容，只能新找一够用空间，并拷贝旧数据。
  - **思考问题**：
     **初始为一个常量，扩容按2倍，那么当不断插入时候，扩容的时间复杂度是多少？**
- A:    
  - 思考：从空开始，连续插n个元素。假设数组的最后大小为2n。
    - 即最后一次copy，申请了2n的空间
      - 把n个数拷贝到新的内存位置。那么花费n时间。
      - 那么前一次，从n/2到n的时候，则花费n/2时间。
    - 得出： 总拷贝次数=n+n/2+n/4+... < 2n，说明还是O(n)时间。
    - 如果考虑均摊：
      - 总体时间/操作次数 = 2n/n，说明均摊是O(1)
- Q：关于回收：假设空间利用率不足25%，那么释放一半空间。
  - **思考问题**：
    从一次扩容到一次释放，你需要删多少次？
- A：
  - 思考：刚扩容过，如果当前整体空间为2n，
     - 那么元素为n个。n空间为空，
     - 那么需要再删除n/2，可到达25%
     - 那么说明还是一个O(n)的删除时间。
     - 考虑均摊：n/2/n，还是一个O(1)的复杂度。
  - 思考：如果阈值是50%，那么会发现
    - 当前为n，插入一个，为n+1，那么空间扩到2n
    - 此时删除一个，那么降到50%，空间又回收到n。
    - 会出现在50%上不断的扩容和回收。
    - 那么会退化为O(n)的复杂度。(均摊也是O(n))
  
  

## 链表



## 例题列表

### Easy
- 合并有序数组
- 去重
- 移动零
- 反转链表
- 合并两个有序链表
- 加一

### Medium
- 有效的括号
- 最小栈
- 后缀表达式求值
- 设计循环双端队列
- 环形链表
- 环形链表II

### Hard
- K个一组翻转链表
- 邻值查找
- 中缀表达式求值
 